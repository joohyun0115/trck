#!/usr/bin/env python
import sys
import tempfile
import os
import subprocess
import time
import argparse
import json
import shutil

sys.path.append(os.path.join(os.path.dirname(sys.argv[0]), '../src'))
import trparser
import fsm2c
import proto_helpers


def capitalize(x):
    return x[0].upper() + x[1:]


def snake_case(x):
    """ ResultTupleExample -> Result_Tuple_Example
        lowerUpper -> Lower_Upper
    """
    y = x[0].upper()
    for i in x[1:]:
        if i.isupper():
            y += "_" + i
        else:
            y += i
    return y


class ScalarProtoInfo(object):
    def __init__(self, package=None, struct=None, path=None):
        self.package = package if package else "trck"
        self.struct = struct if struct else "Result"
        self.path = path if path else "./Results.proto"

    def pb_header(self, basename=False):
        pb_src_file = self.path
        if basename:
            pb_src_file = os.path.basename(pb_src_file)
        return pb_src_file.replace(".proto", ".pb-c.h")

    def pb_src(self, basename=False):
        pb_src_file = self.path
        if basename:
            pb_src_file = os.path.basename(pb_src_file)
        return pb_src_file.replace(".proto", ".pb-c.c")

    def to_struct(self):
        return "{}__{}".format(capitalize(self.package), self.struct)

    def to_struct_init(self):
        return "{}__{}__INIT".format(snake_case(self.package).upper(), snake_case(self.struct).upper())

    def to_get_packed_size(self):
        return "{}__{}__get_packed_size".format(snake_case(self.package).lower(), snake_case(self.struct).lower())

    def to_pack(self):
        return "{}__{}__pack".format(snake_case(self.package).lower(), snake_case(self.struct).lower())


class ProtoInfo(ScalarProtoInfo):
    def __init__(self, package=None, struct=None, row_name_struct=None, path=None):
        self.package = package if package else "trck"
        self.struct = struct if struct else "Results"
        self.path = path if path else "./Results.proto"
        self.row_name_struct = row_name_struct if row_name_struct else ("rows", "Result")

    def to_row_struct(self):
        return "{}__{}__{}".format(
            capitalize(self.package),
            self.struct,
            self.row_name_struct[1],
        )

    def to_row_struct_init(self):
        return "{}__{}__{}__INIT".format(
            snake_case(self.package).upper(),
            snake_case(self.struct).upper(),
            snake_case(self.row_name_struct[1]).upper(),
        )

    def to_row_name(self):
        return self.row_name_struct[0].lower()


def print_(s, level='info'):
    sys.stderr.write("%s\n" % s)

def make_absolute(x):
    return os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), x))

LIBS = ["-ltraildb", make_absolute("../lib/libtrck.a"),
        "-lcmph",
        "-lm",
        "-lJudy",
        "-ljemalloc",
        "-lmsgpackc",
        "-ljson-c",
        "-lprotobuf-c"]

FLAGS = ["-std=c99",
        "-g",
        "-pthread",
        "-Wall",
        "-Wno-unused-variable",
        "-Wno-unused-label",
        "-I", make_absolute("../deps/traildb/src/")] + (os.getenv("CFLAGS").split() if os.getenv("CFLAGS") else [])

def add_debug_flags(flags):
    if os.getenv('DEBUG'):
        flags.append('-DDEBUG=' + os.getenv('DEBUG'))
    else:
        flags.append('-O3')

def compiler(use_openmp):
    if os.getenv('CC'):
        return os.getenv('CC')
    elif sys.platform == 'darwin' and use_openmp:
        return '/usr/local/opt/llvm/bin/clang'
    else:
        return 'gcc'

def compile_dynamic(sources, src_path, gen_path, output_file, use_openmp, extra_libs=[]):
    libs = LIBS[:] + extra_libs
    flags = FLAGS[:]

    if use_openmp:
        if sys.platform == 'darwin':
            flags.append('-L/usr/local/opt/llvm/lib')
            pass
        else:
            if os.getenv('CC') == 'gcc':
                libs.append('-lgomp')  #  don't need this for llvm

        flags.append('-fopenmp')
    else:
        flags.append('-Wno-unknown-pragmas')

    add_debug_flags(flags)
    print ' '.join([compiler(use_openmp)] + flags + \
                           ["-I", gen_path] + \
                           ["-I", src_path] + \
                           sources + \
                           libs + \
                           ["-o", output_file])


    return subprocess.call([compiler(use_openmp)] + flags + \
                           ["-I", gen_path] + \
                           ["-I", src_path] + \
                           sources + \
                           libs + \
                           ["-o", output_file])

def compile_static(sources, src_path, gen_path, output_file, use_openmp, extra_libs=[]):
    libs = LIBS[:] + extra_libs
    flags = FLAGS[:]
    if use_openmp:
        libs.append('-lgomp')
        flags.append('-fopenmp')
    else:
        flags.append('-Wno-unknown-pragmas')

    add_debug_flags(flags)
    # For some reason, when using -static, gcc sets /lib/ld64.so.1 as dynamic
    # linker. Which is technically correct according to amd64 ABI[1], but linux
    # prefers it to be set to /lib64/ld-linux-x86-64.so.2
    #
    # Therefore, binary produced by -static fails with "No such file or
    # directory" at least on my ubuntu box. Hence explicit dynamic linker
    # setting below.

    # [1]http://www.x86-64.org/documentation/abi.pdf
    args = (flags + \
           ["-I", gen_path] + \
           ["-I", src_path] + \
           sources + \
           ["-static"] +\
           libs + \
           ["-Wl,-I/lib64/ld-linux-x86-64.so.2"] +\
           ["-Wl,-Bdynamic"] +\
           ["-o", output_file])
    return subprocess.call([compiler(use_openmp)] + args)

def check_openmp_linux():
    from ctypes import CDLL
    try:
        CDLL("libgomp.so.1")
        return True
    except OSError:
        return False

def check_openmp_osx():
    from ctypes import CDLL
    try:
        CDLL("libiomp5.dylib")
        return True
    except OSError:
        return False


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("program_name", help="program")
    parser.add_argument("traildbs", help="traildb paths", metavar="TDB", nargs="*")
    parser.add_argument("--compile-only", "-c", help="compile only, don't run compiled binary", action='store_true', default=False)
    parser.add_argument("--gen-c", help="compile to C only", action='store_true', default=False)
    parser.add_argument("--gen-h", help="compile header only", action='store_true', default=False)
    parser.add_argument("--output-file", "-o", help="output path for compiled binary", default='matcher-traildb')
    parser.add_argument("--params-file", "-p", help="path to parameter file")
    parser.add_argument('--library', '-l', action='append', help="additional library to link to", default=[])
    parser.add_argument("--proto", help="Path to proto file for results")

    group = parser.add_mutually_exclusive_group()
    group.add_argument("--dynamic", action="store_true", help="link dependencies dynamically (default)")
    group.add_argument("--static", action="store_true", help="link dependencies mostly statically")

    if sys.platform == 'darwin':
        have_openmp = check_openmp_osx()
    else:
        have_openmp = check_openmp_linux()

    group = parser.add_mutually_exclusive_group()
    group.add_argument("--no-openmp", help="do not use openmp", action='store_false', default=have_openmp, dest='use_openmp')
    group.add_argument("--use-openmp", help="use openmp", action='store_true', default=have_openmp, dest='use_openmp')

    args = parser.parse_args()

    if args.static and sys.platform == 'darwin':
        print_("Static linking is not supported on OSX, sorry.")
        sys.exit(1)

    if not args.compile_only and len(args.traildbs) == 0:
        print_("traildb paths required if not using --compile-only", level='error')
        print_(parser.format_usage(), level='error')
        sys.exit(1)

    print_("Compiling %s" % args.program_name)
    t1 = time.time()
    try:
        with open(args.program_name) as f:
            if args.program_name.endswith('.json'):
                flat_rules = (json.load(f))
            else:
                try:
                    flat_rules = trparser.compile_tr(f.read())
                except trparser.ParseError as e:
                    print >>sys.stderr, "Parsing failed: {}".format(e)
                    sys.exit(1)

            gen_path = tempfile.mkdtemp()
            try:
                if args.gen_c:
                    fsm2c.compile(flat_rules["rules"],
                                  includes=['fns_imported.h',
                                            'out_traildb.h'],
                                  groupby=flat_rules.get('groupby'),
                                  out=sys.stdout)
                    return
                elif args.gen_h:
                    fsm2c.gen_header(flat_rules["rules"],
                                     groupby=flat_rules.get('groupby'),
                                     out=sys.stdout)
                    return
                else:
                    with open(os.path.join(gen_path, 'out_traildb.c'), 'w') as c_src:
                        fsm2c.compile(flat_rules["rules"],
                                      includes=['fns_imported.h',
                                                'out_traildb.h'],
                                      groupby=flat_rules.get('groupby'),
                                      out=c_src)
                    if args.proto:
                        proto_info = ProtoInfo('trck', 'Results', ('rows', 'Result'), args.proto)
                        with open(os.path.join(gen_path, 'results_protobuf.c'), 'w') as proto_src:
                            fsm2c.compile_proto(
                                flat_rules["rules"],
                                includes=[
                                    'results_protobuf.h',
                                    proto_info.pb_header(basename=True),
                                ],
                                groupby=flat_rules.get('groupby'),
                                proto_info=proto_info,
                                out=proto_src)

                        subprocess.call([
                            "protoc",
                            "--c_out={}".format(gen_path),
                            # Compile the following proto files and place them into gen_path
                            proto_info.path,
                            "Tuple.proto",
                        ])


                src_path = make_absolute('../src')

                with open(os.path.join(gen_path, 'out_traildb.h'), 'w') as h_src:
                    fsm2c.gen_header(flat_rules["rules"],
                                     groupby=flat_rules.get('groupby'),
                                     out=h_src)

                j = os.path.join
                sources = [
                        j(src_path, "match_traildb.c"),
                        j(src_path, "statevec.c"),
                        j(gen_path, "out_traildb.c"),
                        j(gen_path if args.proto else src_path, "results_protobuf.c"),
                ]
                if args.proto:
                    sources += [
                        j(gen_path, proto_info.pb_src(basename=True)),
                        j(gen_path, "Tuple.pb-c.c"),
                    ]

                if args.static:
                    compile_method = compile_static
                else:
                    compile_method = compile_dynamic

                if os.path.isfile(args.program_name + ".c"):
                    sources.append(args.program_name + ".c")

                if compile_method(sources, src_path, gen_path, args.output_file,
                                  use_openmp=args.use_openmp,
                                  extra_libs=[('-l' + x) for x in (args.library or [])]) != 0:
                    print_("Compilation failed", level='error')
                    sys.exit(1)
            finally:
                print("gen_path {}".format(gen_path))
                # shutil.rmtree(gen_path)

            deltat = time.time() - t1
            print_("Produced binary in %s in %.2f seconds with %s[%s]" % (args.output_file,
                                                                         deltat,
                                                                         compiler(args.use_openmp),
                                                                         'openmp' if args.use_openmp else 'no openmp'
                                                                         ),
                                                                         level='info')

            if not args.compile_only:
                if args.params_file:
                    matcher_args = [args.output_file, '--params', args.params_file]
                else:
                    matcher_args = [args.output_file]
                matcher_args.extend(args.traildbs)
                os.execv(args.output_file, matcher_args)

    except trparser.ParseError as e:
        print_(e, level='error')
        sys.exit(1)

if __name__ == '__main__':
    main()
